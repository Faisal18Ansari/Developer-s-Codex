---
title: "Breaking Down SUPERHOT's Time Mechanic"
slug: breaking-down-superhots-time-mechanic
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1758556217119/0a4879ea-8160-43bb-9d5a-f527894e8b05.avif
tags: unity3d, game-development, csharpprogramming, game-programming, game-mechanics, unitylearning, unitytutorial, superhot, codingtutorial, unitybeginner, source-code, unitydeveloper, opensource, navmeshagents, gamearchitecture

---

## **Introduction**

**SuperHot…SuperHot...SuperHot – Does this ring a bell?**

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758556714265/e6a5a5b4-c7ce-4d86-907c-87923b78108b.jpeg align="center")

---

Picture this: you're standing in a room, bullets frozen mid-air like someone hit the world's most dramatic pause button.

Welcome to SUPERHOT – where "time moves only when you move" isn't just a tagline, it's a developer's nightmare wrapped in pure gaming genius.

As someone who's spent way too many hours yelling at Unity's time system, I decided to recreate this iconic mechanic.

What started as "hey, this looks simple" quickly turned into a masterclass in why game development makes you question your life choices.

Building this taught me more about Unity's guts than any tutorial ever could. We're talking advanced AI state machines, physics synchronization, and input filtering that actually makes sense.

%[https://youtu.be/R4LkToI4xzE?si=Hmx8vt1RQBas_ihu] 

> Source: SUPERHOT YT
> 
> ---

Ready to dive into some time manipulation magic? Let's break reality together.

## **The Core Time Mechanic: Making Unity Bend to Your Will**

Unity's Time.timeScale is both a blessing and a curse. But oh boy can it break things spectacularly.

### **The Foundation: TimeController.cs**

Here's where the magic happens, and where I spent three days debugging why my enemies were ice-skating around like they were auditioning for a horror movie version of Disney on Ice:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758556997812/d387a7e9-abe1-4c6b-9ae1-2db5236f9b69.png align="center")

---

```csharp
public class TimeController : MonoBehaviour
{
    //List of all the controls that are allowed in the game.
    //So the time don't move forward when pressing a non control button.
    public List<KeyCode> AllowedKeys;// Because not every key should break time

    //The Speed the Time speed up and down.
    public float timeScaleAccelrationSpeed;

    bool noKey = true;//This is used to check if any of the allowed keys are pressed.

    void Awake()
    {
        //Start Forzen
        Time.timeScale = 0.05f;

        //Smoothing the TimeScale
        Time.fixedDeltaTime = 0.02F * Time.timeScale;
    }
    void Update()
    {
        noKey = true;
        //if the player pressed Any Allowed Key
        foreach (KeyCode key in AllowedKeys)
            if (Input.GetKey(key))
            {
                noKey = false;
                //Speed Up time
                Time.timeScale = Mathf.MoveTowards(Time.timeScale, 1, timeScaleAccelrationSpeed);

                //Smoothing the TimeScale
                Time.fixedDeltaTime = 0.02f * Time.timeScale;
                break;
            }

        //if no Key Pressed
        if (noKey)
        {
            //Speed Down time
            Time.timeScale = Mathf.MoveTowards(Time.timeScale, 0.05f, timeScaleAccelrationSpeed / 2);

            //Smoothing the TimeScale
            Time.fixedDeltaTime = 0.02f * Time.timeScale;
        }
    }
}
```

---

### **The Three Pillars of Sanity:**

**1\. Input Filtering:**

That &lt;AllowedKeys&gt; list? Pure genius born from frustration. Nothing ruins the SUPERHOT experience quite like accidentally triggering normal time when trying to take a screenshot.

**2\. Smooth Transitions (No Seizure-Inducing Time Jumps):**

See that `MoveTowards` instead of just setting time instantly?

That's the difference between smooth gameplay and jarring time jumps. The trick is using different transition speeds - fast when speeding up time (responsive), slower when slowing down (graceful).

%[https://youtu.be/njzpVA5Fo8k] 

---

**3\. Physics Stability (The Line That Saves Your Sanity):**

Here's what most tutorials ignore: `Time.fixedDeltaTime = 0.02f * Time.timeScale`. Unity's physics system runs separately from game time.

When you slow down the game but don't tell the physics system, you get glitchy behavior - bullets phasing through walls, objects acting weird. This line keeps physics synchronized with your time changes.

%[https://youtu.be/HWGSVQntlxU?si=BQXShqflMTqFsRj0] 

> For a deeper Dive in the Time Mechanic watch **Fadrik’s Video on Time Manipulation**
> 
> ---

## **Advanced AI State Machine: When Your Enemies Actually Have Brains**

Now, here's where things get spicy. Most SUPERHOT clones slap together some basic enemy movement and call it a day.

Instead of cramming everything into one massive enemy script that would make spaghetti code look organized, I went with Unity's StateMachineBehaviour system.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758557663536/b3a94d95-d44a-4c7f-b822-1f0aeaef047d.png align="center")

---

Each AI state is its own script, clean and focused like a well-organized toolbox

```csharp
public class Chasing : StateMachineBehaviour
{
    public float stopChasingDistance = 21f; // "You're too far, I give up"
    public float attackRange = 2.5f; // "Now it's personal"

    override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        agent.SetDestination(player.position); 
        float distance = Vector3.Distance(player.position, animator.transform.position);
        
        if (distance > stopChasingDistance)
            animator.SetBool("CHASE", false); / / "Whatever, you're not worth it"
        if (distance < attackRange)
            animator.SetBool("ATTACK", true); // "SAY HELLO TO MY LITTLE... fist?"
    }
}
```

---

### **The Three Zones of Enemy Enlightenment:**

* **2.5f Attack Range**: "I can touch you, prepare to die"
    
* **13f Detection Range**: "I see you, the chase is on"
    
* **21f Give Up Range**: "Whatever, you're not worth it"
    

The genius here is in the transitions. Enemies don't just flip between states like a broken light switch – they smoothly transition based on actual spatial relationships

My Walking.cs creates patrol patterns that feel organic with random waypoint selection. Enemies don't follow the same route like brain-dead security guards – they actually seem like they have places to be, right up until they spot you.

```csharp
// Random waypoint selection - because predictable AI is boring AI
Vector3 nextPosition = wayPoints[Random.Range(0, wayPoints.Count)].position;
agent.SetDestination(nextPosition);
```

---

%[https://youtu.be/qE2IAsU_mKg?si=isVT8hx5eeEcM3go] 

> Mike explains it way better in his video on State Machine
> 
> ---

## **Combat & Physics Integration: Making Bullets Matter**

Most games fake their shooting with raycasts and instant hits. We're going full physics because we're not cowards:

```csharp
public Vector3 CalculateDirection()
    {
        // Shooting from the middle of the screen (like civilized people)
        Ray ray = cam.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0));
        RaycastHit hit;
        Vector3 targetPoint;// The point the player is aiming at
        if (Physics.Raycast(ray, out hit))
        {
            targetPoint = hit.point;// Hit something solid
        }
        else
        {   
            // Shooting at hopes and dreams
            targetPoint = ray.GetPoint(100);//If nothing is hit, shoot at a point 75 units away
        }
        Vector3 direction = targetPoint - firePoint.position;

        // Add some spread because perfect accuracy is for robots
        float spreadX = Random.Range(-spreadIntensity, spreadIntensity);
        float spreadY = Random.Range(-spreadIntensity, spreadIntensity);

        // Return direction and spread
        return direction + new Vector3(spreadX, spreadY, 0);
    }
```

---

This converts screen center to world space, calculates trajectory, and adds realistic spread.

%[https://youtu.be/Exs1CvUn45U] 

The result? Shooting that feels weighty and satisfying, not like you're firing laser pointers. They bounce, fall, and actually behave like projectiles.

## **Implementation Challenges: The "Why Did I Choose This Path?" Section**

**Challenge #1: NavMesh vs. Time Scaling**  
Ever seen an AI enemy trying to navigate during slow-motion? It's like watching someone walk through molasses while their pathfinding has an existential crisis. The solution? Careful speed synchronization and animation matching.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758558875109/7c08814b-0715-4cbb-84ef-7c7abfc69f0b.png align="center")

---

**Challenge #2: Physics Synchronization**  
That fixedDeltaTime line exists because I spent an entire evening watching bullets phase through walls like enlightened spirits. Unity's physics doesn't automatically adjust to time scaling – you have to hold its hand through the process.

**Challenge #3: Animation Timing**  
Getting enemy animations to sync with NavMesh movement during variable time scales is like conducting an orchestra where every musician plays at different tempos. The trick is proportional speed adjustments and careful timing.

## **Key Learnings: What This Project Taught Me**

Building this SUPERHOT clone was like taking a masterclass in "Unity Systems You Thought You Understood." Here's what I learned:

**Architecture Matters More Than You Think**: Modular design isn't just for show – it's the difference between debugging one focused script and hunting bugs through a thousand-line monster.

**Time is Cruel**: Unity's time system is powerful but unforgiving. Respect it, understand it, and always adjust your physics timing.

%[https://youtu.be/yGhfUcPjXuE?si=kDYOOf69-D7464Pj] 

> Understand Time Better through Jonas’s Video on deltaTime
> 
> ---

**State Machines Are Life**: For complex AI behavior, StateMachineBehaviour components beat massive Update() loops every single time.

## **Conclusion & Your Next Steps**

So there you have it – a SUPERHOT clone that doesn't just work, but works well. We've covered time manipulation that doesn't break physics, AI that acts intelligently, and combat that feels satisfying.

**What's in the GitHub repo**: Complete source code, detailed comments like "WHY DOES TIME HATE ME" (we've all been there).

%[https://github.com/Faisal18Ansari/SuperHot.git] 

**Your mission, should you choose to accept it:** Take this foundation and make it your own. Add particle effects, implement different enemy types, or go completely off the rails.

The architecture is solid enough to handle whatever chaos you throw at it.

**Questions for the community**:

### What time-based mechanics would you add?

### Drop your war stories in the comments – debugging stories are always better with an audience.

### Comment down below if I should make a video on the SUPERHOT Time mechanic.

***P.S. - If you manage to break this system in creative ways, I both applaud your ingenuity and offer my condolences for your debugging marathon.***
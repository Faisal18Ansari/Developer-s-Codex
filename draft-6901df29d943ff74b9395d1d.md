---
title: "Slicing Through Code: How I Built Fruit Ninja"
slug: slicing-through-code-how-i-built-fruit-ninja
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1762106363160/2ba72ab4-7849-40b9-b112-c80b44d0460f.png

---

## **The Fruit Salad of Game Development**

Ever wondered what happens when a developer meets flying fruit? Spoiler alert: there's juice everywhere and I questioned my life choices at least 47 times.

Building a Fruit Ninja clone seemed simple enough â€“ slice fruit, avoid bombs, get points.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762106399660/b5c9c5b2-f470-4406-927a-b04c1cca5bc3.png align="center")

Reality check: nothing in game development is simple.

After watching countless tutorials and drowning in Unity documentation, I emerged with a working game and enough war stories to last a lifetime.

## **Setting Up the Project**

First things first: project organization matters! I learned this the hard way after spending 20 minutes looking for a script I misplaced.

Here's how I structured my project:

**Scripts folder** - All C# code goes here

**Prefabs folder** - Reusable game objects like fruits and bombs

**Materials folder** - Colors and textures for our objects

**Models folder** - 3D fruit meshes

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762106437086/00179292-e342-4f64-a988-2470f12bf806.png align="center")

The key lesson? Organization saves time.

Trust me, your future self will thank you when you're not digging through a messy project at 2 AM trying to find that one important script!

## **The Spawner: Making Fruit Rain From Heaven**

The Spawner is responsible for creating fruit and launching them into the air.

This was my first real encounter with Coroutines - Unity's way of handling time-based events.

Here's the core spawning logic from my Spawner.cs:

```csharp
 private IEnumerator Spawn()
    {
        // Give the player a moment to prepare, then begin random chaos.
        yield return new WaitForSeconds(2f);

        while (enabled)
        {
            // Pick a fruit at random (or a bomb, if fate is unkind).
            GameObject prefab = fruitPrefabs[Random.Range(0, fruitPrefabs.Length)];

            if (Random.value < bombChance) {
                prefab = bombPrefab; // curveball!
            }

            // Pick a random position inside the spawn area's bounds.
            Vector3 position = new Vector3
            {
                x = Random.Range(spawnArea.bounds.min.x, spawnArea.bounds.max.x),
                y = Random.Range(spawnArea.bounds.min.y, spawnArea.bounds.max.y),
                z = Random.Range(spawnArea.bounds.min.z, spawnArea.bounds.max.z)
            };

            Quaternion rotation = Quaternion.Euler(0f, 0f, Random.Range(minAngle, maxAngle));

            GameObject fruit = Instantiate(prefab, position, rotation);
            Destroy(fruit, maxLifetime); // clean up when it's old and tired

            float force = Random.Range(minForce, maxForce);
            fruit.GetComponent<Rigidbody>().AddForce(fruit.transform.up * force, ForceMode.Impulse);

            // Wait a random time before spawning the next fruity tragedy.
            yield return new WaitForSeconds(Random.Range(minSpawnDelay, maxSpawnDelay));
        }
    }
```

### Understanding the Code

Let me break this down:

**Coroutines** let us pause execution and wait for specific conditions. The `yield return new WaitForSeconds()` pauses our function for a set time.

**Random.Range()** gives us variety - different fruits spawn at different times and positions, making gameplay unpredictable and fun.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762106553653/78755e55-68fd-495f-877e-233e857a1cba.png align="center")

**Physics Forces** are applied using `AddForce()` with `ForceMode.Impulse` for instant launching. Think of it like kicking a ball - one quick burst of energy sends it flying!

The bounds system uses a collider to define our spawn area. Unity calculates the minimum and maximum points automatically, so we just pick random coordinates within that box.

## **The Blade: Detecting Player Input**

The blade follows your finger or mouse and detects when it hits fruit. This required handling both **desktop mouse input** and **mobile touch input**. Here's how I solved this challenge:

```csharp
private void Update()
    {
#if UNITY_EDITOR || UNITY_STANDALONE
        if(Input.GetMouseButtonDown(0))
            StartSlice();
        
        else if(Input.GetMouseButtonUp(0))
            EndSlice();
        
        else if(slicing)
            ContinueSlice(Input.mousePosition);
#elif UNITY_IOS || UNITY_ANDROID
        if(Input.touchCount>0)
        {
            Touch touch=Input.GetTouch(0);
            switch (touch.phase)
            {
                case TouchPhase.Began:
                    StartSlice(touch.position);
                    break;
                case TouchPhase.Moved:
                    if (slicing) ContinueSlice(touch.position);
                    break;
                case TouchPhase.Ended:
                case TouchPhase.Canceled:
                    EndSlice();
                    break;
            }
        }
#endif
    }
```

### Why This Code Works

The **preprocessor directives** (#if, #elif, #endif) let us write different code for different platforms. Unity automatically includes the right version when building for desktop vs mobile.

**Screen to World Point** conversion is crucial because your mouse/finger position is in screen pixels, but game objects exist in world units. Think of it like translating between different languages!

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762106643214/6824bc4c-4764-4170-bed8-a46629bc7a2a.png align="center")

The **velocity threshold** (\`minSliceVelocity\`) prevents accidental slices. You have to actually swipe with intent - gentle touches won't trigger cuts.

This makes the game feel more responsive and intentional.

## **Fruit Physics: The Satisfying Slice**

When the blade hits a fruit, magic happens! The fruit needs to split into pieces, create particle effects, and award points. Here's the slicing logic from Fruit.cs:

```csharp
 private void Sliced(Vector3 direction, Vector3 position, float force)
    {
        // Sliced: handle the glorious aftermath. Swap models, play particles,
        // fling the slices like a tiny salad being thrown across the room.
        FindAnyObjectByType<GameManager>().IncreaseScore(point);
        whole.SetActive(false);
        sliced.SetActive(true);
        if (fruitCollider != null) fruitCollider.enabled = false;
        if (juiceEffect != null) juiceEffect.Play();
        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        sliced.transform.rotation = Quaternion.Euler(0f, 0f, angle);
        Rigidbody[] slices = sliced.GetComponentsInChildren<Rigidbody>();
        foreach (Rigidbody slice in slices)
        {
            // Give each slice the original fruit's velocity and an extra push
            slice.velocity = rb.velocity;
            slice.AddForceAtPosition(direction * force, position, ForceMode.Impulse);
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        // If the blade touches the fruit, tell the fruit to accept its fate.
        if (other.CompareTag("Player"))
        {
            Blade blade = other.GetComponent<Blade>();
            // Defensive: make sure blade isn't null (just in case a friendly ghost bumped it)
            if (blade != null)
                Sliced(blade.direction, blade.transform.position, blade.sliceForce);
        }
    }
```

### The Magic Behind the Slice

**Collision Detection** uses `OnTriggerEnter()` - this function automatically runs when objects overlap. Unity handles all the complex math!

**Model Swapping** creates the illusion of cutting. We simply hide the whole fruit and show the pre-made sliced version.

It's like a magic trick - the audience sees seamless cutting, but we're just swapping props behind the scenes.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762106739468/442baed4-d968-4fb5-b7ec-94e409fd6ae4.png align="center")

**Force Application** at specific positions makes pieces fly apart realistically. `AddForceAtPosition()` simulates the blade pushing through the fruit.

**Particle Effects** provide that satisfying juice splash. Visual feedback is crucial for making actions feel impactful and fun!

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762106755760/634a485d-4396-430b-bc67-724258dd77b4.png align="center")

## **The Bomb: Keeping Players on Their Toes**

Bombs add risk to the game. Hit one and it's game over! The bomb logic is surprisingly simple but effective:

```csharp
private void OnTriggerEnter(Collider other)
    {
        // If the player (i.e. blade) touches this, inform the GameManager and brace for
        // consequences. We use FindObjectOfType because this is a tiny game and we like
        // doing things the lazy-but-effective way.
        if (other.CompareTag("Player"))
        {
            FindObjectOfType<GameManager>().Explode();
        }
    }
```

## **Game Manager: The Brain of the Operation**

The GameManager coordinates everything - scoring, game states, and the dramatic explosion sequence when you hit a bomb:

```csharp
public void IncreaseScore(int amount)
    {
        // IncreaseScore: called when the player does something worthy of points.
        // We add the points, update the text, and pretend we didn't just get lucky.
        score += amount;
        if (scoreText != null)
            scoreText.text = "Score: " + score.ToString();
    }
    public void Explode()
    {
        // Explode: the moment someone touches a bomb and the game throws a tantrum.
        // We disable controls/spawning, show 'Game Over', and run a little sequence.
        if (blade != null) blade.enabled = false;
        if (spawner != null) spawner.enabled = false;
        if (scoreText != null) scoreText.text += "\nGame Over!";
        else Debug.LogWarning("GameManager: scoreText not set when Explode called.");

        StartCoroutine(ExplodeSequence());
    }
    private IEnumerator ExplodeSequence()
    {
        // ExplodeSequence: do a quick flash, wait, then reset. It's basically the game's dramatic
        // sigh followed by a broom-and-mop routine.
        float elapsed = 0f;
        float duration = 0.5f;
        while (elapsed < duration)
        {
            float t = Mathf.Clamp01(elapsed / duration);
            if (flash != null)
                flash.color = Color.Lerp(Color.clear, Color.white, t);
            Time.timeScale = 1f;
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        yield return new WaitForSecondsRealtime(1f);
        NewGame();
        elapsed = 0f;
        while (elapsed < duration)
        {
            float t = Mathf.Clamp01(elapsed / duration);
            if (flash != null)
                flash.color = Color.Lerp(Color.white, Color.clear, t);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
    }
```

## **Cross-Platform Magic**

One of the coolest things about this project is that the same code works on desktop and mobile!

Unity's input system automatically translates mouse clicks to touch events, and the physics simulation runs identically on both platforms.

The **preprocessor directives** ensure we handle input correctly for each platform, while the core game logic remains unchanged.

This is the power of good abstraction - write once, run everywhere!

## **Visual Polish: Making It Shine**

The difference between a programming exercise and a real game often comes down to polish:

**Trail Renderers** create those satisfying swoosh lines behind your blade. Particle Systems make juice explosions feel impactful.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762106939320/b5416434-d326-446d-b47e-e16af5473e13.png align="center")

Proper lighting and shadows add depth and professionalism.

These aren't just decoration - they're psychological feedback that makes actions feel meaningful and satisfying.

A slice without visual impact feels hollow, but add particles and trail effects, and suddenly it feels like you're wielding a real blade!

## **Debugging Adventures**

Building this game taught me valuable debugging skills. **Null reference** exceptions were my biggest enemy - always check if objects exist before using them! ðŸ¥²

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762106958202/02f1d9ee-de5b-4bd5-8fe6-8ba3c8d71060.png align="center")

Physics tuning required lots of experimentation. Finding the right balance between realistic and fun physics took dozens of test builds and adjustments.

The most important lesson? Test on real devices early and often.

What works perfectly in the Unity editor might behave completely differently on an actual phone or tablet.

### You can watch Zigurous for the complete fruit ninja Tutorial in unity:

%[https://youtu.be/xTT1Ae_ifhM?si=UBwqX7NgSwr_fps-] 

## **What I Learned**

%[https://youtu.be/BeRrxFHLlSM?si=STFwfzpBBsQUaexi] 

This project taught me several key concepts:

**Component-Based Architecture:** Unity's system where objects have multiple components (Rigidbody, Collider, etc.) working together. This makes code modular and reusable.

**Physics Simulation:** Understanding forces, velocities, and collisions. Games feel more natural when they follow physical laws (even if simplified).

**State Management**: Coordinating between different game states (playing, paused, game over) and ensuring smooth transitions.

**Cross-Platform Development:** Writing code that works on multiple devices with different input methods.

You can find the Github Repository here:

%[https://github.com/Faisal18Ansari/Fruit-Ninja] 

You start with basic functionality and gradually add polish, effects, and refinements.

**Each small improvement makes the experience significantly better!**